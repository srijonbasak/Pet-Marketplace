const express = require('express');
const router = express.Router();
const { auth } = require('../middleware/auth');
const Invoice = require('../models/Invoice');
const Product = require('../models/Product');
const Employee = require('../models/Employee');
const Shop = require('../models/Shop');

// Create new invoice (employee only)
router.post('/', auth, async (req, res) => {
  try {
    console.log('Invoice creation request received:', req.body);
    const employee = await Employee.findById(req.user.id);
    if (!employee || !employee.isActive) {
      return res.status(403).json({ message: 'Unauthorized' });
    }

    if (!employee.permissions.canCreateInvoices) {
      return res.status(403).json({ message: 'No permission to create invoices' });
    }

    const {
      customerName,
      customerPhone,
      customerEmail,
      items,
      subtotal,
      tax,
      discount,
      total,
      paymentMethod,
      notes
    } = req.body;

    console.log('Processing invoice with items:', items);

    // Validate products and update inventory
    for (const item of items) {
      try {
        const product = await Product.findOne({ _id: item.product, shop: employee.shop });
        if (!product) {
          return res.status(400).json({ message: `Product ${item.product} not found` });
        }
        if (product.stock < item.quantity) {
          return res.status(400).json({ message: `Insufficient stock for ${product.name}` });
        }
        // Update product stock
        product.stock -= item.quantity;
        await product.save();
      } catch (itemError) {
        console.error('Error processing item:', itemError);
        return res.status(400).json({ message: `Error processing product: ${itemError.message}` });
      }
    }

    // Create new invoice without invoiceNumber - will be generated by pre-save hook
    const invoice = new Invoice({
      shop: employee.shop,
      createdBy: employee._id,
      customerName,
      customerPhone,
      customerEmail,
      items,
      subtotal,
      tax,
      discount,
      total,
      paymentMethod,
      notes
    });

    console.log('Saving invoice...');
    const savedInvoice = await invoice.save();
    console.log('Invoice saved successfully:', savedInvoice);
    
    res.status(201).json(savedInvoice);
  } catch (error) {
    console.error('Error creating invoice:', error);
    res.status(500).json({ 
      message: error.message,
      error: error.toString(),
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Get all invoices for a shop (employee only)
router.get('/shop', auth, async (req, res) => {
  try {
    const employee = await Employee.findById(req.user.id);
    if (!employee || !employee.isActive) {
      return res.status(403).json({ message: 'Unauthorized' });
    }

    const invoices = await Invoice.find({ shop: employee.shop })
      .populate('createdBy', 'firstName lastName')
      .populate('items.product', 'name price')
      .sort({ createdAt: -1 });

    res.json(invoices);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get all invoices for a seller's shop (seller only)
router.get('/seller/shop', auth, async (req, res) => {
  try {
    // First check if the user has a shop
    const shop = await Shop.findOne({ owner: req.user.id });
    if (!shop) {
      return res.status(404).json({ message: 'Shop not found' });
    }

    // Fetch all invoices for this shop
    const invoices = await Invoice.find({ shop: shop._id })
      .populate('createdBy', 'firstName lastName')
      .populate('items.product', 'name price')
      .sort({ createdAt: -1 });

    res.json(invoices);
  } catch (error) {
    console.error('Error fetching seller shop invoices:', error);
    res.status(500).json({ message: error.message });
  }
});

// Get single invoice (employee only)
router.get('/:id', auth, async (req, res) => {
  try {
    const employee = await Employee.findById(req.user.id);
    if (!employee || !employee.isActive) {
      return res.status(403).json({ message: 'Unauthorized' });
    }

    const invoice = await Invoice.findOne({
      _id: req.params.id,
      shop: employee.shop
    })
      .populate('createdBy', 'firstName lastName')
      .populate('items.product', 'name price description');

    if (!invoice) {
      return res.status(404).json({ message: 'Invoice not found' });
    }

    res.json(invoice);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Update invoice status (employee only)
router.put('/:id/status', auth, async (req, res) => {
  try {
    const employee = await Employee.findById(req.user.id);
    if (!employee || !employee.isActive) {
      return res.status(403).json({ message: 'Unauthorized' });
    }

    const { paymentStatus } = req.body;
    const invoice = await Invoice.findOne({
      _id: req.params.id,
      shop: employee.shop
    });

    if (!invoice) {
      return res.status(404).json({ message: 'Invoice not found' });
    }

    invoice.paymentStatus = paymentStatus;
    await invoice.save();

    res.json(invoice);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get invoice statistics (employee only)
router.get('/stats/shop', auth, async (req, res) => {
  try {
    const employee = await Employee.findById(req.user.id);
    if (!employee || !employee.isActive) {
      return res.status(403).json({ message: 'Unauthorized' });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const stats = await Invoice.aggregate([
      {
        $match: {
          shop: employee.shop,
          createdAt: { $gte: today }
        }
      },
      {
        $group: {
          _id: null,
          totalSales: { $sum: '$total' },
          totalInvoices: { $sum: 1 },
          averageInvoiceValue: { $avg: '$total' }
        }
      }
    ]);

    res.json(stats[0] || {
      totalSales: 0,
      totalInvoices: 0,
      averageInvoiceValue: 0
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

module.exports = router; 